/*
nextcloud

Nextcloud APIs

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FilesSharingShareapiAPI interface {

	/*
	FilesSharingShareapiAcceptShare Accept a share

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the share
	@return FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest
	*/
	FilesSharingShareapiAcceptShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest

	// FilesSharingShareapiAcceptShareExecute executes the request
	//  @return CoreWhatsNewDismiss200Response
	FilesSharingShareapiAcceptShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest) (*CoreWhatsNewDismiss200Response, *http.Response, error)

	/*
	FilesSharingShareapiCreateShare Create a share

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest
	*/
	FilesSharingShareapiCreateShare(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest

	// FilesSharingShareapiCreateShareExecute executes the request
	//  @return FilesSharingShareapiCreateShare200Response
	FilesSharingShareapiCreateShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error)

	/*
	FilesSharingShareapiDeleteShare Delete a share

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the share
	@return FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest
	*/
	FilesSharingShareapiDeleteShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest

	// FilesSharingShareapiDeleteShareExecute executes the request
	//  @return CoreWhatsNewDismiss200Response
	FilesSharingShareapiDeleteShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest) (*CoreWhatsNewDismiss200Response, *http.Response, error)

	/*
	FilesSharingShareapiGetInheritedShares Get all shares relative to a file, including parent folders shares rights

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest
	*/
	FilesSharingShareapiGetInheritedShares(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest

	// FilesSharingShareapiGetInheritedSharesExecute executes the request
	//  @return FilesSharingShareapiGetShares200Response
	FilesSharingShareapiGetInheritedSharesExecute(r FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error)

	/*
	FilesSharingShareapiGetShare Get a specific share by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the share
	@return FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest
	*/
	FilesSharingShareapiGetShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest

	// FilesSharingShareapiGetShareExecute executes the request
	//  @return FilesSharingShareapiCreateShare200Response
	FilesSharingShareapiGetShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error)

	/*
	FilesSharingShareapiGetShares Get shares of the current user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest
	*/
	FilesSharingShareapiGetShares(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest

	// FilesSharingShareapiGetSharesExecute executes the request
	//  @return FilesSharingShareapiGetShares200Response
	FilesSharingShareapiGetSharesExecute(r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error)

	/*
	FilesSharingShareapiPendingShares Get all shares that are still pending

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest
	*/
	FilesSharingShareapiPendingShares(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest

	// FilesSharingShareapiPendingSharesExecute executes the request
	//  @return FilesSharingShareapiGetShares200Response
	FilesSharingShareapiPendingSharesExecute(r FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error)

	/*
	FilesSharingShareapiUpdateShare Update a share

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the share
	@return FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest
	*/
	FilesSharingShareapiUpdateShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest

	// FilesSharingShareapiUpdateShareExecute executes the request
	//  @return FilesSharingShareapiCreateShare200Response
	FilesSharingShareapiUpdateShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error)
}

// FilesSharingShareapiAPIService FilesSharingShareapiAPI service
type FilesSharingShareapiAPIService service

type FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	id string
	oCSAPIRequest *string
}

func (r FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest) Execute() (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiAcceptShareExecute(r)
}

/*
FilesSharingShareapiAcceptShare Accept a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiAcceptShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CoreWhatsNewDismiss200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiAcceptShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiAcceptShareRequest) (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreWhatsNewDismiss200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiAcceptShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/pending/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	oCSAPIRequest *string
	path *string
	permissions *int64
	shareType *int64
	shareWith *string
	publicUpload *string
	password *string
	sendPasswordByTalk *string
	expireDate *string
	note *string
	label *string
	attributes *string
}

func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// Path of the share
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) Path(path string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.path = &path
	return r
}

// Permissions for the share
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) Permissions(permissions int64) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.permissions = &permissions
	return r
}

// Type of the share
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) ShareType(shareType int64) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.shareType = &shareType
	return r
}

// The entity this should be shared with
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) ShareWith(shareWith string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.shareWith = &shareWith
	return r
}

// If public uploading is allowed
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) PublicUpload(publicUpload string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.publicUpload = &publicUpload
	return r
}

// Password for the share
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) Password(password string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.password = &password
	return r
}

// Send the password for the share over Talk
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) SendPasswordByTalk(sendPasswordByTalk string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.sendPasswordByTalk = &sendPasswordByTalk
	return r
}

// Expiry date of the share
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) ExpireDate(expireDate string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.expireDate = &expireDate
	return r
}

// Note for the share
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) Note(note string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.note = &note
	return r
}

// Label for the share (only used in link and email)
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) Label(label string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.label = &label
	return r
}

// Additional attributes for the share
func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) Attributes(attributes string) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	r.attributes = &attributes
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) Execute() (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiCreateShareExecute(r)
}

/*
FilesSharingShareapiCreateShare Create a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiCreateShare(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiCreateShare200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiCreateShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiCreateShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiCreateShare200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiCreateShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	}
	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "")
	}
	if r.shareType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareType", r.shareType, "")
	}
	if r.shareWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareWith", r.shareWith, "")
	}
	if r.publicUpload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicUpload", r.publicUpload, "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	if r.sendPasswordByTalk != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendPasswordByTalk", r.sendPasswordByTalk, "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expireDate", r.expireDate, "")
	}
	if r.note != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "note", r.note, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	id string
	oCSAPIRequest *string
}

func (r FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest) Execute() (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiDeleteShareExecute(r)
}

/*
FilesSharingShareapiDeleteShare Delete a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiDeleteShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CoreWhatsNewDismiss200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiDeleteShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiDeleteShareRequest) (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreWhatsNewDismiss200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiDeleteShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	path *string
	oCSAPIRequest *string
}

// Path all shares will be relative to
func (r FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest) Path(path string) FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest {
	r.path = &path
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest) Execute() (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiGetInheritedSharesExecute(r)
}

/*
FilesSharingShareapiGetInheritedShares Get all shares relative to a file, including parent folders shares rights

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiGetInheritedShares(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiGetShares200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiGetInheritedSharesExecute(r FilesSharingShareapiAPIFilesSharingShareapiGetInheritedSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiGetShares200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiGetInheritedShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/inherited"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	id string
	oCSAPIRequest *string
	includeTags *int32
}

func (r FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// Include tags in the share
func (r FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest) IncludeTags(includeTags int32) FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest {
	r.includeTags = &includeTags
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest) Execute() (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiGetShareExecute(r)
}

/*
FilesSharingShareapiGetShare Get a specific share by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiGetShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiCreateShare200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiGetShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiGetShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiCreateShare200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiGetShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.includeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tags", r.includeTags, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	oCSAPIRequest *string
	sharedWithMe *string
	reshares *string
	subfiles *string
	path *string
	includeTags *string
}

func (r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// Only get shares with the current user
func (r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) SharedWithMe(sharedWithMe string) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest {
	r.sharedWithMe = &sharedWithMe
	return r
}

// Only get shares by the current user and reshares
func (r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) Reshares(reshares string) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest {
	r.reshares = &reshares
	return r
}

// Only get all shares in a folder
func (r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) Subfiles(subfiles string) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest {
	r.subfiles = &subfiles
	return r
}

// Get shares for a specific path
func (r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) Path(path string) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest {
	r.path = &path
	return r
}

// Include tags in the share
func (r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) IncludeTags(includeTags string) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest {
	r.includeTags = &includeTags
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) Execute() (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiGetSharesExecute(r)
}

/*
FilesSharingShareapiGetShares Get shares of the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiGetShares(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiGetShares200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiGetSharesExecute(r FilesSharingShareapiAPIFilesSharingShareapiGetSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiGetShares200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiGetShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.sharedWithMe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared_with_me", r.sharedWithMe, "")
	}
	if r.reshares != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reshares", r.reshares, "")
	}
	if r.subfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subfiles", r.subfiles, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	}
	if r.includeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tags", r.includeTags, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	oCSAPIRequest *string
}

func (r FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest) Execute() (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiPendingSharesExecute(r)
}

/*
FilesSharingShareapiPendingShares Get all shares that are still pending

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiPendingShares(ctx context.Context) FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiGetShares200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiPendingSharesExecute(r FilesSharingShareapiAPIFilesSharingShareapiPendingSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiGetShares200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiPendingShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest struct {
	ctx context.Context
	ApiService FilesSharingShareapiAPI
	id string
	oCSAPIRequest *string
	permissions *int64
	password *string
	sendPasswordByTalk *string
	publicUpload *string
	expireDate *string
	note *string
	label *string
	hideDownload *string
	attributes *string
}

func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) OCSAPIRequest(oCSAPIRequest string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// New permissions
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) Permissions(permissions int64) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.permissions = &permissions
	return r
}

// New password
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) Password(password string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.password = &password
	return r
}

// New condition if the password should be send over Talk
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) SendPasswordByTalk(sendPasswordByTalk string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.sendPasswordByTalk = &sendPasswordByTalk
	return r
}

// New condition if public uploading is allowed
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) PublicUpload(publicUpload string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.publicUpload = &publicUpload
	return r
}

// New expiry date
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) ExpireDate(expireDate string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.expireDate = &expireDate
	return r
}

// New note
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) Note(note string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.note = &note
	return r
}

// New label
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) Label(label string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.label = &label
	return r
}

// New condition if the download should be hidden
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) HideDownload(hideDownload string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.hideDownload = &hideDownload
	return r
}

// New additional attributes
func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) Attributes(attributes string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	r.attributes = &attributes
	return r
}

func (r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) Execute() (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiUpdateShareExecute(r)
}

/*
FilesSharingShareapiUpdateShare Update a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest
*/
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiUpdateShare(ctx context.Context, id string) FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest {
	return FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiCreateShare200Response
func (a *FilesSharingShareapiAPIService) FilesSharingShareapiUpdateShareExecute(r FilesSharingShareapiAPIFilesSharingShareapiUpdateShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiCreateShare200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiAPIService.FilesSharingShareapiUpdateShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	if r.sendPasswordByTalk != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendPasswordByTalk", r.sendPasswordByTalk, "")
	}
	if r.publicUpload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicUpload", r.publicUpload, "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expireDate", r.expireDate, "")
	}
	if r.note != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "note", r.note, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.hideDownload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hideDownload", r.hideDownload, "")
	}
	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
