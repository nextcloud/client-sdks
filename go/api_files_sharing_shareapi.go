/*
nextcloud

Nextcloud APIs

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FilesSharingShareapiApiService FilesSharingShareapiApi service
type FilesSharingShareapiApiService service

type ApiFilesSharingShareapiAcceptShareRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	id string
	oCSAPIRequest *string
}

func (r ApiFilesSharingShareapiAcceptShareRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiAcceptShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r ApiFilesSharingShareapiAcceptShareRequest) Execute() (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiAcceptShareExecute(r)
}

/*
FilesSharingShareapiAcceptShare Accept a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return ApiFilesSharingShareapiAcceptShareRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiAcceptShare(ctx context.Context, id string) ApiFilesSharingShareapiAcceptShareRequest {
	return ApiFilesSharingShareapiAcceptShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CoreWhatsNewDismiss200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiAcceptShareExecute(r ApiFilesSharingShareapiAcceptShareRequest) (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreWhatsNewDismiss200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiAcceptShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/pending/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilesSharingShareapiCreateShareRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	oCSAPIRequest *string
	path *string
	permissions *int64
	shareType *int64
	shareWith *string
	publicUpload *string
	password *string
	sendPasswordByTalk *string
	expireDate *string
	note *string
	label *string
	attributes *string
}

func (r ApiFilesSharingShareapiCreateShareRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiCreateShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// Path of the share
func (r ApiFilesSharingShareapiCreateShareRequest) Path(path string) ApiFilesSharingShareapiCreateShareRequest {
	r.path = &path
	return r
}

// Permissions for the share
func (r ApiFilesSharingShareapiCreateShareRequest) Permissions(permissions int64) ApiFilesSharingShareapiCreateShareRequest {
	r.permissions = &permissions
	return r
}

// Type of the share
func (r ApiFilesSharingShareapiCreateShareRequest) ShareType(shareType int64) ApiFilesSharingShareapiCreateShareRequest {
	r.shareType = &shareType
	return r
}

// The entity this should be shared with
func (r ApiFilesSharingShareapiCreateShareRequest) ShareWith(shareWith string) ApiFilesSharingShareapiCreateShareRequest {
	r.shareWith = &shareWith
	return r
}

// If public uploading is allowed
func (r ApiFilesSharingShareapiCreateShareRequest) PublicUpload(publicUpload string) ApiFilesSharingShareapiCreateShareRequest {
	r.publicUpload = &publicUpload
	return r
}

// Password for the share
func (r ApiFilesSharingShareapiCreateShareRequest) Password(password string) ApiFilesSharingShareapiCreateShareRequest {
	r.password = &password
	return r
}

// Send the password for the share over Talk
func (r ApiFilesSharingShareapiCreateShareRequest) SendPasswordByTalk(sendPasswordByTalk string) ApiFilesSharingShareapiCreateShareRequest {
	r.sendPasswordByTalk = &sendPasswordByTalk
	return r
}

// Expiry date of the share
func (r ApiFilesSharingShareapiCreateShareRequest) ExpireDate(expireDate string) ApiFilesSharingShareapiCreateShareRequest {
	r.expireDate = &expireDate
	return r
}

// Note for the share
func (r ApiFilesSharingShareapiCreateShareRequest) Note(note string) ApiFilesSharingShareapiCreateShareRequest {
	r.note = &note
	return r
}

// Label for the share (only used in link and email)
func (r ApiFilesSharingShareapiCreateShareRequest) Label(label string) ApiFilesSharingShareapiCreateShareRequest {
	r.label = &label
	return r
}

// Additional attributes for the share
func (r ApiFilesSharingShareapiCreateShareRequest) Attributes(attributes string) ApiFilesSharingShareapiCreateShareRequest {
	r.attributes = &attributes
	return r
}

func (r ApiFilesSharingShareapiCreateShareRequest) Execute() (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiCreateShareExecute(r)
}

/*
FilesSharingShareapiCreateShare Create a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFilesSharingShareapiCreateShareRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiCreateShare(ctx context.Context) ApiFilesSharingShareapiCreateShareRequest {
	return ApiFilesSharingShareapiCreateShareRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiCreateShare200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiCreateShareExecute(r ApiFilesSharingShareapiCreateShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiCreateShare200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiCreateShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	}
	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "")
	}
	if r.shareType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareType", r.shareType, "")
	}
	if r.shareWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareWith", r.shareWith, "")
	}
	if r.publicUpload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicUpload", r.publicUpload, "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	if r.sendPasswordByTalk != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendPasswordByTalk", r.sendPasswordByTalk, "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expireDate", r.expireDate, "")
	}
	if r.note != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "note", r.note, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilesSharingShareapiDeleteShareRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	id string
	oCSAPIRequest *string
}

func (r ApiFilesSharingShareapiDeleteShareRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiDeleteShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r ApiFilesSharingShareapiDeleteShareRequest) Execute() (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiDeleteShareExecute(r)
}

/*
FilesSharingShareapiDeleteShare Delete a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return ApiFilesSharingShareapiDeleteShareRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiDeleteShare(ctx context.Context, id string) ApiFilesSharingShareapiDeleteShareRequest {
	return ApiFilesSharingShareapiDeleteShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CoreWhatsNewDismiss200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiDeleteShareExecute(r ApiFilesSharingShareapiDeleteShareRequest) (*CoreWhatsNewDismiss200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreWhatsNewDismiss200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiDeleteShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilesSharingShareapiGetInheritedSharesRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	path *string
	oCSAPIRequest *string
}

// Path all shares will be relative to
func (r ApiFilesSharingShareapiGetInheritedSharesRequest) Path(path string) ApiFilesSharingShareapiGetInheritedSharesRequest {
	r.path = &path
	return r
}

func (r ApiFilesSharingShareapiGetInheritedSharesRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiGetInheritedSharesRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r ApiFilesSharingShareapiGetInheritedSharesRequest) Execute() (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiGetInheritedSharesExecute(r)
}

/*
FilesSharingShareapiGetInheritedShares Get all shares relative to a file, including parent folders shares rights

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFilesSharingShareapiGetInheritedSharesRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiGetInheritedShares(ctx context.Context) ApiFilesSharingShareapiGetInheritedSharesRequest {
	return ApiFilesSharingShareapiGetInheritedSharesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiGetShares200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiGetInheritedSharesExecute(r ApiFilesSharingShareapiGetInheritedSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiGetShares200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiGetInheritedShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/inherited"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilesSharingShareapiGetShareRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	id string
	oCSAPIRequest *string
	includeTags *int32
}

func (r ApiFilesSharingShareapiGetShareRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiGetShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// Include tags in the share
func (r ApiFilesSharingShareapiGetShareRequest) IncludeTags(includeTags int32) ApiFilesSharingShareapiGetShareRequest {
	r.includeTags = &includeTags
	return r
}

func (r ApiFilesSharingShareapiGetShareRequest) Execute() (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiGetShareExecute(r)
}

/*
FilesSharingShareapiGetShare Get a specific share by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return ApiFilesSharingShareapiGetShareRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiGetShare(ctx context.Context, id string) ApiFilesSharingShareapiGetShareRequest {
	return ApiFilesSharingShareapiGetShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiCreateShare200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiGetShareExecute(r ApiFilesSharingShareapiGetShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiCreateShare200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiGetShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.includeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tags", r.includeTags, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilesSharingShareapiGetSharesRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	oCSAPIRequest *string
	sharedWithMe *string
	reshares *string
	subfiles *string
	path *string
	includeTags *string
}

func (r ApiFilesSharingShareapiGetSharesRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiGetSharesRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// Only get shares with the current user
func (r ApiFilesSharingShareapiGetSharesRequest) SharedWithMe(sharedWithMe string) ApiFilesSharingShareapiGetSharesRequest {
	r.sharedWithMe = &sharedWithMe
	return r
}

// Only get shares by the current user and reshares
func (r ApiFilesSharingShareapiGetSharesRequest) Reshares(reshares string) ApiFilesSharingShareapiGetSharesRequest {
	r.reshares = &reshares
	return r
}

// Only get all shares in a folder
func (r ApiFilesSharingShareapiGetSharesRequest) Subfiles(subfiles string) ApiFilesSharingShareapiGetSharesRequest {
	r.subfiles = &subfiles
	return r
}

// Get shares for a specific path
func (r ApiFilesSharingShareapiGetSharesRequest) Path(path string) ApiFilesSharingShareapiGetSharesRequest {
	r.path = &path
	return r
}

// Include tags in the share
func (r ApiFilesSharingShareapiGetSharesRequest) IncludeTags(includeTags string) ApiFilesSharingShareapiGetSharesRequest {
	r.includeTags = &includeTags
	return r
}

func (r ApiFilesSharingShareapiGetSharesRequest) Execute() (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiGetSharesExecute(r)
}

/*
FilesSharingShareapiGetShares Get shares of the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFilesSharingShareapiGetSharesRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiGetShares(ctx context.Context) ApiFilesSharingShareapiGetSharesRequest {
	return ApiFilesSharingShareapiGetSharesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiGetShares200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiGetSharesExecute(r ApiFilesSharingShareapiGetSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiGetShares200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiGetShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.sharedWithMe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared_with_me", r.sharedWithMe, "")
	}
	if r.reshares != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reshares", r.reshares, "")
	}
	if r.subfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subfiles", r.subfiles, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	}
	if r.includeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tags", r.includeTags, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilesSharingShareapiPendingSharesRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	oCSAPIRequest *string
}

func (r ApiFilesSharingShareapiPendingSharesRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiPendingSharesRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

func (r ApiFilesSharingShareapiPendingSharesRequest) Execute() (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiPendingSharesExecute(r)
}

/*
FilesSharingShareapiPendingShares Get all shares that are still pending

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFilesSharingShareapiPendingSharesRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiPendingShares(ctx context.Context) ApiFilesSharingShareapiPendingSharesRequest {
	return ApiFilesSharingShareapiPendingSharesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiGetShares200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiPendingSharesExecute(r ApiFilesSharingShareapiPendingSharesRequest) (*FilesSharingShareapiGetShares200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiGetShares200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiPendingShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilesSharingShareapiUpdateShareRequest struct {
	ctx context.Context
	ApiService *FilesSharingShareapiApiService
	id string
	oCSAPIRequest *string
	permissions *int64
	password *string
	sendPasswordByTalk *string
	publicUpload *string
	expireDate *string
	note *string
	label *string
	hideDownload *string
	attributes *string
}

func (r ApiFilesSharingShareapiUpdateShareRequest) OCSAPIRequest(oCSAPIRequest string) ApiFilesSharingShareapiUpdateShareRequest {
	r.oCSAPIRequest = &oCSAPIRequest
	return r
}

// New permissions
func (r ApiFilesSharingShareapiUpdateShareRequest) Permissions(permissions int64) ApiFilesSharingShareapiUpdateShareRequest {
	r.permissions = &permissions
	return r
}

// New password
func (r ApiFilesSharingShareapiUpdateShareRequest) Password(password string) ApiFilesSharingShareapiUpdateShareRequest {
	r.password = &password
	return r
}

// New condition if the password should be send over Talk
func (r ApiFilesSharingShareapiUpdateShareRequest) SendPasswordByTalk(sendPasswordByTalk string) ApiFilesSharingShareapiUpdateShareRequest {
	r.sendPasswordByTalk = &sendPasswordByTalk
	return r
}

// New condition if public uploading is allowed
func (r ApiFilesSharingShareapiUpdateShareRequest) PublicUpload(publicUpload string) ApiFilesSharingShareapiUpdateShareRequest {
	r.publicUpload = &publicUpload
	return r
}

// New expiry date
func (r ApiFilesSharingShareapiUpdateShareRequest) ExpireDate(expireDate string) ApiFilesSharingShareapiUpdateShareRequest {
	r.expireDate = &expireDate
	return r
}

// New note
func (r ApiFilesSharingShareapiUpdateShareRequest) Note(note string) ApiFilesSharingShareapiUpdateShareRequest {
	r.note = &note
	return r
}

// New label
func (r ApiFilesSharingShareapiUpdateShareRequest) Label(label string) ApiFilesSharingShareapiUpdateShareRequest {
	r.label = &label
	return r
}

// New condition if the download should be hidden
func (r ApiFilesSharingShareapiUpdateShareRequest) HideDownload(hideDownload string) ApiFilesSharingShareapiUpdateShareRequest {
	r.hideDownload = &hideDownload
	return r
}

// New additional attributes
func (r ApiFilesSharingShareapiUpdateShareRequest) Attributes(attributes string) ApiFilesSharingShareapiUpdateShareRequest {
	r.attributes = &attributes
	return r
}

func (r ApiFilesSharingShareapiUpdateShareRequest) Execute() (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	return r.ApiService.FilesSharingShareapiUpdateShareExecute(r)
}

/*
FilesSharingShareapiUpdateShare Update a share

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the share
 @return ApiFilesSharingShareapiUpdateShareRequest
*/
func (a *FilesSharingShareapiApiService) FilesSharingShareapiUpdateShare(ctx context.Context, id string) ApiFilesSharingShareapiUpdateShareRequest {
	return ApiFilesSharingShareapiUpdateShareRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FilesSharingShareapiCreateShare200Response
func (a *FilesSharingShareapiApiService) FilesSharingShareapiUpdateShareExecute(r ApiFilesSharingShareapiUpdateShareRequest) (*FilesSharingShareapiCreateShare200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesSharingShareapiCreateShare200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesSharingShareapiApiService.FilesSharingShareapiUpdateShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocs/v2.php/apps/files_sharing/api/v1/shares/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oCSAPIRequest == nil {
		return localVarReturnValue, nil, reportError("oCSAPIRequest is required and must be specified")
	}

	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	if r.sendPasswordByTalk != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendPasswordByTalk", r.sendPasswordByTalk, "")
	}
	if r.publicUpload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicUpload", r.publicUpload, "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expireDate", r.expireDate, "")
	}
	if r.note != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "note", r.note, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.hideDownload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hideDownload", r.hideDownload, "")
	}
	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "OCS-APIRequest", r.oCSAPIRequest, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
